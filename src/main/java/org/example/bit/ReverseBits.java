package org.example.bit;

/**
 * 190. 颠倒二进制位
 * 颠倒给定的 32 位无符号整数的二进制位。
 * 请注意，在某些语言（如 Java）中，没有无符号整数类型。
 * 在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，
 * 因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
 * 在 Java 中，编译器使用二进制补码记法来表示有符号整数。
 * 因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
 * 示例 1：
 * 输入：n = 00000010100101000001111010011100
 * 输出：964176192 (00111001011110000010100101000000)
 * 解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
 * 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
 * 示例 2：
 * 输入：n = 11111111111111111111111111111101
 * 输出：3221225471 (10111111111111111111111111111111)
 * 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
 * 因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
 */
public class ReverseBits {

    /**
     * 算法思路：通过位操作逐位颠倒32位整数。
     * 关键在于利用位移操作将最低位移到最高位，依次类推。
     */
    public static int reverseBits(int n) {
        int result = 0; // 用于存储反转后的结果

        System.out.println("开始反转: " + String.format("%32s", Integer.toBinaryString(n)).replace(' ', '0') + " (原始)");

        // 逐位处理32位
        for (int i = 0; i < 32; i++) {
            // 打印当前的二进制表示
            System.out.printf("当前 n 的二进制表示: %32s%n", String.format("%32s", Integer.toBinaryString(n)).replace(' ', '0'));

            // 取出最低位
            int bit = n & 1;
            System.out.println("提取的最低位: " + bit);

            // 将最低位移到结果中的正确位置
            result |= bit << (31 - i);

            // 打印当前位和中间结果，确保每行保持32位输出
            System.out.printf("步骤 %2d: 当前位 = %d, 中间结果 = %32s%n", i + 1, bit, String.format("%32s", Integer.toBinaryString(result)).replace(' ', '0'));

            // 右移n一位，准备处理下一位
            n >>>= 1;

            // 打印右移后的 n 的二进制表示
            System.out.printf("右移后的 n: %32s%n", String.format("%32s", Integer.toBinaryString(n)).replace(' ', '0'));
        }

        System.out.println("最终反转结果: " + String.format("%32s", Integer.toBinaryString(result)).replace(' ', '0') + " (二进制), " + result + " (十进制)");
        return result; // 返回最终的反转结果
    }

    public static void main(String[] args) {
        //输入 00000010100101000001111010011100，预期输出: 964176192
        //输出 00111001011110000010100101000000
        System.out.println("反转结果: " + reverseBits(0b00000010100101000001111010011100));

        //输入11111111111111111111111111111101，预期输出: 3221225471
        //输出10111111111111111111111111111111
        System.out.println("反转结果: " + reverseBits(0b11111111111111111111111111111101));
    }
}
